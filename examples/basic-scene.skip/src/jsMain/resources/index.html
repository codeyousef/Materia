<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Materia Basic Scene Example</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #materia-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .info-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 250px;
        }

        .info-overlay h3 {
            margin: 0 0 10px 0;
            color: #4fc3f7;
            font-size: 16px;
        }

        .controls {
            margin: 10px 0;
        }

        .controls div {
            margin: 2px 0;
            font-size: 12px;
        }

        .stats {
            margin-top: 10px;
            font-size: 11px;
            opacity: 0.8;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 8px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .loading h2 {
            margin: 0 0 10px 0;
            color: #4fc3f7;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #4fc3f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .warning {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 152, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }
    </style>
</head>
<body>
<!-- Canvas for 3D rendering -->
<canvas id="materia-canvas"></canvas>

<!-- Info overlay -->
<div class="info-overlay">
    <h3>ðŸš€ Materia 3D Engine</h3>
    <div><strong>Controls:</strong></div>
    <div class="controls">
        <div>WASD - Move camera</div>
        <div>Q/E - Move up/down</div>
        <div>Mouse - Look around (drag)</div>
    </div>
    <div class="stats">
        <div>FPS: <span id="fps">--</span></div>
        <div>Objects: <span id="objects">--</span></div>
        <div>Renderer: <span id="renderer">WebGPU</span></div>
    </div>
</div>

<!-- Loading indicator -->
<div id="loading" class="loading">
    <h2>Loading Materia</h2>
    <div class="spinner"></div>
    <div>Initializing 3D engine...</div>
</div>

<!-- WebGPU warning -->
<div id="webgpu-warning" class="warning">
    WebGPU not supported. Falling back to WebGL.
</div>

<script>
    // Check for WebGPU support
    if (!navigator.gpu) {
        document.getElementById('webgpu-warning').style.display = 'block';
        document.getElementById('renderer').textContent = 'WebGL';
    }

    // Handle canvas resize
    function resizeCanvas() {
        const canvas = document.getElementById('materia-canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Prevent context menu on right click
    document.addEventListener('contextmenu', (e) => e.preventDefault());

    // Hide loading after initialization
    window.addEventListener('load', () => {
        setTimeout(() => {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.style.opacity = '0';
                loading.style.transition = 'opacity 0.5s';
                setTimeout(() => loading.remove(), 500);
            }
        }, 2000);
    });

    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();

    function updateFPS() {
        frameCount++;
        const currentTime = performance.now();

        if (currentTime - lastTime >= 1000) {
            const fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
            document.getElementById('fps').textContent = fps;
            frameCount = 0;
            lastTime = currentTime;
        }

        requestAnimationFrame(updateFPS);
    }

    updateFPS();

    // WebGL Demo - Render a rotating cube
    const canvas = document.getElementById('materia-canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    if (gl) {
        // Vertex shader
        const vsSource = `
                attribute vec3 aPosition;
                attribute vec3 aColor;
                uniform mat4 uProjectionMatrix;
                uniform mat4 uModelViewMatrix;
                varying vec3 vColor;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                    vColor = aColor;
                }
            `;

        // Fragment shader
        const fsSource = `
                precision mediump float;
                varying vec3 vColor;
                void main() {
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `;

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create shaders
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        // Create program
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(shaderProgram));
        }

        gl.useProgram(shaderProgram);

        // Get attribute/uniform locations
        const positionLoc = gl.getAttribLocation(shaderProgram, 'aPosition');
        const colorLoc = gl.getAttribLocation(shaderProgram, 'aColor');
        const projMatrixLoc = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
        const mvMatrixLoc = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');

        // Cube vertices and colors (all 6 faces)
        const vertices = new Float32Array([
            // Front face
            -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,
            // Back face
            -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1,
            // Top face
            -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1,
            // Bottom face
            -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,
            // Right face
            1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1,
            // Left face
            -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1
        ]);

        const colors = new Float32Array([
            // Front face - red
            1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
            // Back face - green
            0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
            // Top face - blue
            0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
            // Bottom face - yellow
            1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0,
            // Right face - magenta
            1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,
            // Left face - cyan
            0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1
        ]);

        const indices = new Uint16Array([
            0, 1, 2, 0, 2, 3,    // Front
            4, 5, 6, 4, 6, 7,    // Back
            8, 9, 10, 8, 10, 11,  // Top
            12, 13, 14, 12, 14, 15, // Bottom
            16, 17, 18, 16, 18, 19, // Right
            20, 21, 22, 20, 22, 23  // Left
        ]);

        // Create buffers
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        // Matrix helpers
        function perspective(fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function identity() {
            return new Float32Array([
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1
            ]);
        }

        function translate(m, x, y, z) {
            m[12] += x;
            m[13] += y;
            m[14] += z;
        }

        function rotateY(m, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const m0 = m[0], m2 = m[2];
            m[0] = m0 * c - m[2] * s;
            m[2] = m0 * s + m[2] * c;
        }

        function rotateX(m, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const m5 = m[5], m6 = m[6];
            m[5] = m5 * c + m[9] * s;
            m[6] = m6 * c + m[10] * s;
            m[9] = m[9] * c - m5 * s;
            m[10] = m[10] * c - m6 * s;
        }

        // Set projection
        const projMatrix = perspective(75 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100);
        gl.uniformMatrix4fv(projMatrixLoc, false, projMatrix);

        // Camera controls
        let cameraPos = {x: 0, y: 0, z: 0};
        let cameraRot = {x: 0, y: 0};
        let keys = {};
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            keys[e.key.toUpperCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toUpperCase()] = false;
        });

        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            mouseDown = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        document.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (!mouseDown) return;

            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;

            cameraRot.y += deltaX * 0.005;
            cameraRot.x += deltaY * 0.005;

            // Clamp vertical rotation
            cameraRot.x = Math.max(-1.5, Math.min(1.5, cameraRot.x));

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        // Update camera position based on keys
        function updateCamera() {
            const speed = 0.1;

            // Forward/backward (W/S)
            if (keys['W']) {
                cameraPos.z += speed * Math.cos(cameraRot.y);
                cameraPos.x -= speed * Math.sin(cameraRot.y);
            }
            if (keys['S']) {
                cameraPos.z -= speed * Math.cos(cameraRot.y);
                cameraPos.x += speed * Math.sin(cameraRot.y);
            }

            // Strafe left/right (A/D)
            if (keys['A']) {
                cameraPos.x += speed * Math.cos(cameraRot.y);
                cameraPos.z += speed * Math.sin(cameraRot.y);
            }
            if (keys['D']) {
                cameraPos.x -= speed * Math.cos(cameraRot.y);
                cameraPos.z -= speed * Math.sin(cameraRot.y);
            }

            // Move up/down (Q/E)
            if (keys['Q']) cameraPos.y += speed;
            if (keys['E']) cameraPos.y -= speed;
        }

        // Animation
        let objectCount = 3;

        function render(time) {
            // Update camera
            updateCamera();

            // Clear
            gl.clearColor(0.05, 0.05, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, canvas.width, canvas.height);

            // Draw multiple cubes
            for (let i = 0; i < objectCount; i++) {
                const mvMatrix = identity();

                // Apply camera transforms (inverse)
                rotateX(mvMatrix, -cameraRot.x);
                rotateY(mvMatrix, -cameraRot.y);
                translate(mvMatrix, -cameraPos.x, -cameraPos.y, -cameraPos.z);

                // Position and rotate cube
                translate(mvMatrix, (i - 1) * 3, 0, -8);
                rotateY(mvMatrix, time * 0.001 + i);
                rotateX(mvMatrix, time * 0.0007);

                gl.uniformMatrix4fv(mvMatrixLoc, false, mvMatrix);

                // Bind buffers
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(positionLoc);

                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(colorLoc);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            }

            // Update object count display
            document.getElementById('objects').textContent = objectCount;

            requestAnimationFrame(render);
        }

        render(0);
    } else {
        console.error('WebGL not supported!');
        document.getElementById('renderer').textContent = 'Not Available';
    }
</script>
</body>
</html>