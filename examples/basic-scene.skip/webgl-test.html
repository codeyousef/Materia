<!DOCTYPE html>
<html>
<head>
    <title>Materia WebGL Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="info">
    <h3>ðŸš€ Materia WebGL Test</h3>
    <div>FPS: <span id="fps">--</span></div>
    <div>If you see rotating cubes, WebGL is working!</div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
        alert('WebGL not supported!');
    }

    // Vertex shader
    const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uModelViewMatrix;
            varying vec3 vColor;

            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;

    // Fragment shader
    const fsSource = `
            precision mediump float;
            varying vec3 vColor;

            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    // Create shaders and program
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(shaderProgram));
    }

    gl.useProgram(shaderProgram);

    // Get locations
    const positionLoc = gl.getAttribLocation(shaderProgram, 'aPosition');
    const colorLoc = gl.getAttribLocation(shaderProgram, 'aColor');
    const projMatrixLoc = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
    const mvMatrixLoc = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');

    // Cube vertices
    const vertices = new Float32Array([
        -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,  // Front
        -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1   // Back
    ]);

    const colors = new Float32Array([
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,  // Red front
        0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0   // Green back
    ]);

    const indices = new Uint16Array([
        0, 1, 2, 0, 2, 3,  // Front
        4, 5, 6, 4, 6, 7,  // Back
        0, 4, 7, 0, 7, 1,  // Bottom
        3, 2, 6, 3, 6, 5,  // Top
        0, 3, 5, 0, 5, 4,  // Left
        1, 7, 6, 1, 6, 2   // Right
    ]);

    // Create buffers
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    // Matrix functions
    function perspective(fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy / 2);
        const nf = 1 / (near - far);
        return new Float32Array([
            f / aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (far + near) * nf, -1,
            0, 0, 2 * far * near * nf, 0
        ]);
    }

    function identity() {
        return new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
    }

    function translate(m, x, y, z) {
        m[12] += x;
        m[13] += y;
        m[14] += z;
    }

    function rotateY(m, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const m0 = m[0], m2 = m[2];
        m[0] = m0 * c - m[2] * s;
        m[2] = m0 * s + m[2] * c;
    }

    // Set projection matrix
    const projMatrix = perspective(75 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100);
    gl.uniformMatrix4fv(projMatrixLoc, false, projMatrix);

    // Animation
    let frameCount = 0;
    let lastTime = performance.now();

    function render(time) {
        // Clear
        gl.clearColor(0.05, 0.05, 0.1, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Draw rotating cube
        const mvMatrix = identity();
        translate(mvMatrix, 0, 0, -5);
        rotateY(mvMatrix, time * 0.001);

        gl.uniformMatrix4fv(mvMatrixLoc, false, mvMatrix);

        // Bind buffers
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLoc);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(colorLoc);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

        // FPS
        frameCount++;
        if (time - lastTime >= 1000) {
            document.getElementById('fps').textContent = Math.round(frameCount * 1000 / (time - lastTime));
            frameCount = 0;
            lastTime = time;
        }

        requestAnimationFrame(render);
    }

    render(0);

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
</script>
</body>
</html>